% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clean_fq.R
\name{clean_fq}
\alias{clean_fq}
\title{Removes the noise of an individual fastq file}
\usage{
clean_fq(
  fq.file,
  min.coverage.threshold = 2L,
  remove.unique.reads = TRUE,
  write.blacklist = FALSE,
  write.blacklist.fasta = FALSE,
  parallel.core = parallel::detectCores() - 1
)
}
\arguments{
\item{fq.file}{(character, path). The path to the individual fastq file to check.
Default: \code{fq.file = "my-sample.fq.gz"}.}

\item{min.coverage.threshold}{(character, path). Minimum coverage threshold.
The function will remove distinct reads with coverage <= to the threshold.
Default: \code{min.coverage.threshold = 2L}.}

\item{remove.unique.reads}{(logical). Remove distinct unique reads with high
coverage. Likely paralogs or Transposable elements.
Default: \code{remove.unique.reads = TRUE}.}

\item{write.blacklist}{(logical). Write the blacklisted reads to a file.
Default: \code{write.blacklist = FALSE}.}

\item{write.blacklist.fasta}{(logical). Write the blacklisted reads to a
fasta file.
Default: \code{write.blacklist.fasta = FALSE}.}

\item{parallel.core}{(integer) Enable parallel execution with the number of threads.
Default: \code{parallel.core = parallel::detectCores() - 1}.}
}
\value{
The function returns a cleaned fq file with the name of the sample and
\code{_cleaned} appended to the filename.
}
\description{
This function reads the fastq file of an individual and clean it
by removing:
\itemize{
\item unique reads with high coverage (likely paralogs or TE)
\item distinct reads with low coverage
}
}
\details{
coming soon, just try it in the meantime...
}
\examples{
\dontrun{
require(vroom)
clean.id <- stackr::clean_fq(
  fq.file = "my-sample.fq.gz",
  min.coverage.threshold = 7,
  remove.unique.reads = TRUE,
  write.blacklist.fasta = TRUE
  )
}
}
